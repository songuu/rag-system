# 领域向量匹配逻辑完整说明

## 一、核心概念

### 1.1 什么是领域向量？
领域向量是通过将一组代表特定领域的"种子词"转换为向量嵌入（Embedding），然后计算这些向量的**质心（Centroid）**得到的。质心代表了该领域在高维语义空间中的"中心位置"。

### 1.2 为什么需要质心？
- **降维简化**: 将数十个种子词压缩为一个代表向量
- **语义聚合**: 捕获领域的整体语义特征
- **快速匹配**: 只需计算查询向量与质心的相似度

## 二、完整计算流程

### 2.1 种子词向量化

```
输入: ["代码", "算法", "架构", "数据库", ...]
     ↓ Ollama Embedding API (nomic-embed-text)
输出: [
  [0.023, -0.145, 0.089, ...],  // "代码" 的 768 维向量
  [0.012, -0.098, 0.123, ...],  // "算法" 的 768 维向量
  ...
]
```

**关键参数**:
- **模型**: `nomic-embed-text`
- **维度**: 768 维浮点数向量
- **API**: `http://localhost:11434/api/embeddings`

### 2.2 质心计算

质心是所有种子词向量的**归一化平均值**：

```javascript
// 步骤 1: 计算平均值
for (每个维度 i) {
  centroid[i] = (v1[i] + v2[i] + ... + vn[i]) / n
}

// 步骤 2: 归一化（L2 范数）
norm = sqrt(centroid[0]² + centroid[1]² + ... + centroid[767]²)
for (每个维度 i) {
  centroid[i] = centroid[i] / norm
}
```

**数学公式**:
```
Centroid = Normalize( (v₁ + v₂ + ... + vₙ) / n )
```

**归一化的目的**:
- 将向量模长统一为 1
- 消除向量长度差异的影响
- 使余弦相似度计算更稳定

### 2.3 查询向量生成

```
输入: "如何优化数据库性能？"
     ↓ Ollama Embedding API
输出: [0.045, -0.023, 0.167, ...] (768 维)
     ↓ 归一化
输出: [0.0452, -0.0231, 0.1678, ...] (模长 = 1)
```

### 2.4 余弦相似度计算

余弦相似度是衡量两个向量"方向相似程度"的指标：

```javascript
// 计算点积
dotProduct = query[0] * centroid[0] + query[1] * centroid[1] + ... + query[767] * centroid[767]

// 计算模长
queryNorm = sqrt(query[0]² + query[1]² + ... + query[767]²)
centroidNorm = sqrt(centroid[0]² + centroid[1]² + ... + centroid[767]²)

// 余弦相似度
similarity = dotProduct / (queryNorm * centroidNorm)
```

**数学公式**:
```
cos(θ) = (A · B) / (||A|| × ||B||)
```

**取值范围**:
- **1.0**: 完全相同方向（完美匹配）
- **0.0**: 正交（无关）
- **-1.0**: 完全相反方向（语义相反）

**实际应用中**:
- **> 0.7**: 强相关
- **0.5 - 0.7**: 中等相关
- **< 0.5**: 弱相关

## 三、可视化展示内容

### 3.1 查询向量信息
```
🔍 查询向量信息
  维度: 768
  模长: 1.0000 (已归一化)
  向量样本 (前20维): [0.045231, -0.023145, ...]
```

### 3.2 统计指标
```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ 平均相似度   │ 标准差       │ 分数范围     │ 向量维度     │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 83.20%       │ 1.45%        │ 2.90%        │ 768          │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

**指标解释**:
- **平均相似度**: 所有领域的相似度均值，用于判断查询的区分度
- **标准差**: 相似度的离散程度，越大说明领域区分越明显
- **分数范围**: 最高分与最低分的差值
- **向量维度**: 向量空间的维度数

### 3.3 详细计算过程（展开每个领域）

```
🏆 1. 技术 (💻) - 85.42%
  ┌─ 计算过程 ────────────────────────────────────┐
  │ 点积 (Dot Product):     0.854187             │
  │ 查询模长:                1.000000             │
  │ 质心模长:                1.000000             │
  │                                               │
  │ similarity = 0.854187 / (1.0 × 1.0)          │
  │            = 0.854187 = 85.42%               │
  └───────────────────────────────────────────────┘
  
  📊 统计指标
    偏离均值: +2.22%    (高于平均值)
    Z-Score:  +1.531σ   (显著偏离，说明匹配度突出)
    种子词数: 25 词
  
  🎯 贡献最大的维度 (Top 5)
    1. 维度342: 0.002341  ████████████░░░░░░
    2. 维度089: 0.001987  ██████████░░░░░░░░
    3. 维度512: 0.001654  ████████░░░░░░░░░░
    4. 维度203: 0.001432  ███████░░░░░░░░░░░
    5. 维度678: 0.001209  ██████░░░░░░░░░░░░
  
  📝 种子词样本
    [代码] [算法] [架构] [数据库] [并发] [接口] 
    [部署] [系统] [开发] [模型]
```

### 3.4 Z-Score 解释

**Z-Score（标准分数）**用于判断某个领域的相似度是否显著高于平均水平：

```
Z-Score = (相似度 - 平均值) / 标准差
```

**判断标准**:
- **Z > +2**: 非常显著高于平均（97.5% 置信度）
- **Z > +1**: 显著高于平均（84% 置信度）
- **-1 < Z < +1**: 接近平均水平
- **Z < -1**: 显著低于平均

**示例**:
```
技术领域: 85.42%
平均值:   83.20%
标准差:   1.45%

Z-Score = (85.42 - 83.20) / 1.45 = +1.531σ
解释: 技术领域相似度比平均值高 1.531 个标准差，
      属于显著匹配。
```

## 四、常见问题诊断

### 4.1 为什么相似度都很高但差异很小？

**原因分析**:
1. **种子词重叠**: 不同领域使用了相似的通用词
2. **向量空间密集**: 所有领域质心在高维空间中距离较近
3. **查询过于通用**: 查询包含通用词汇，与多个领域都有关联

**解决方案**:
- 优化种子词，增加领域特异性词汇
- 移除高频通用词（如"优化"、"方法"）
- 增加种子词数量（从 25 个增加到 50-100 个）

### 4.2 如何提高匹配准确度？

**方法 1: 优化种子词质量**
```
❌ 不好的种子词:
  技术领域: ["好", "快", "优化", "方法", ...]  (太通用)

✅ 好的种子词:
  技术领域: ["PyTorch", "Kubernetes", "React Hooks", 
            "数据库索引", "并发锁", ...]  (具体且专业)
```

**方法 2: 增加种子词数量**
- 25 词: 基础覆盖
- 50 词: 较好覆盖
- 100 词: 全面覆盖

**方法 3: 使用 AI 生成种子词**
```
点击 "🤖 AI生成" 按钮
→ llama3.1 根据领域描述自动生成 50 个专业词汇
→ 可以手动筛选和补充
```

### 4.3 查看详细调试信息

在测试页面，展开任意领域可查看：
1. **计算过程**: 点积、模长、相似度公式
2. **贡献维度**: 哪些向量维度对相似度贡献最大
3. **种子词样本**: 该领域使用的种子词
4. **统计偏离**: Z-Score 和偏离均值的程度

## 五、最佳实践

### 5.1 种子词选择原则
1. **专业性**: 选择领域特有的专业术语
2. **覆盖性**: 涵盖领域的各个子方向
3. **排他性**: 避免与其他领域重叠
4. **多样性**: 包含名词、动词、概念等多种类型

### 5.2 测试和调优流程
```
1. 使用 AI 生成初始种子词
   ↓
2. 计算质心
   ↓
3. 用典型查询测试
   ↓
4. 查看详细计算过程，找出问题
   ↓
5. 优化种子词（添加/删除/替换）
   ↓
6. 重新计算质心
   ↓
7. 重复 3-6 直到满意
```

### 5.3 性能优化
- **批量计算**: 使用"批量计算所有质心"功能
- **缓存结果**: 质心保存在 `data/centroids.json`
- **增量更新**: 只更新修改过的领域

## 六、技术栈

| 组件 | 技术 | 说明 |
|------|------|------|
| LLM | llama3.1 | 生成领域种子词 |
| Embedding | nomic-embed-text | 将文本转换为 768 维向量 |
| 相似度算法 | 余弦相似度 | 计算向量间的语义距离 |
| 数据存储 | JSON 文件 | 本地存储质心数据 |
| 可视化 | React + TailwindCSS | 交互式可视化界面 |

## 七、API 参考

### 7.1 测试查询 API
```javascript
POST /api/domain-vectors
{
  "action": "test-query",
  "query": "如何优化数据库性能？",
  "showDetails": true  // 是否返回详细计算过程
}

// 返回
{
  "success": true,
  "query": "如何优化数据库性能？",
  "similarities": [...],  // 所有领域相似度
  "topDomain": {...},     // 最匹配领域
  "stats": {              // 统计信息
    "mean": 0.8320,
    "std": 0.0145,
    "range": 0.0290,
    "queryNorm": 1.0000,
    "queryDim": 768
  },
  "queryVector": {        // 查询向量信息
    "dimension": 768,
    "norm": 1.0000,
    "sample": [...]
  }
}
```

### 7.2 计算质心 API
```javascript
POST /api/domain-vectors
{
  "action": "calculate-centroid",
  "domain": "tech",
  "seedWords": ["代码", "算法", ...]
}
```

## 八、数学公式总结

| 计算步骤 | 公式 |
|----------|------|
| 向量归一化 | `v' = v / ||v||` |
| 质心计算 | `C = Normalize(Σvᵢ / n)` |
| 点积 | `A · B = Σ(aᵢ × bᵢ)` |
| 欧几里得范数 | `||v|| = √(Σvᵢ²)` |
| 余弦相似度 | `cos(θ) = (A·B) / (||A|| × ||B||)` |
| Z-Score | `Z = (x - μ) / σ` |

---

**版本**: v1.0
**最后更新**: 2026-01-14
